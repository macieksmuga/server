"""
DO NOT EDIT THIS FILE!!
This file is automatically generated by the process_schemas.py program
in the scripts directory. It is not intended to be edited directly. If
you need to update the GA4GH protocol classes, please run the script
on the appropriate schema version.
"""
from protocol import ProtocolElement
from protocol import SearchRequest
from protocol import SearchResponse

import avro.schema

version = '0.6.a'


class Allele(ProtocolElement):
    """
`Allele`s are the key component of the "allelic" model of variation: they are
single objects that are present in some copy number.

An `Allele` is a contiguous piece of sequence that we will want to say is
present (in general at some copy number) or absent in a sample. Very often it
will just be a single `Segment` covering the entirety of a novel `Sequence`, but
it is also common for it to be a mix of `Segment`s on reference and novel
`Sequence`s, or in general to be any contiguous path through the augmented
sequence graph.

`Allele`s belong to `VariantSet`s. `Allele`s can also be used to represent the
reference and alternate alleles of `Variant`s.

Note that `Path`s cannot follow `Join`s not represented in the augmented
sequence graph. For example, if  an `Allele` that spans a novel deletion is
required, a new `Join` should exist to describe that deletion, available through
`searchJoins()`.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Allele",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"doc": "",
"type": "string", "name": "variantSetId"}, {"doc": "", "type": {"doc":
"", "type": "record", "name": "Path", "fields": [{"default": [],
"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"Segment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Side", "fields": [{"doc": "", "type": {"doc": "",
"type": "record", "name": "Position", "fields": [{"default": null,
"doc": "", "type": ["null", "string"], "name": "sequenceId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceName"}, {"doc": "", "type": "long", "name": "position"}]},
"name": "base"}, {"doc": "", "type": {"symbols": ["NEG_STRAND",
"POS_STRAND"], "doc": "", "type": "enum", "name": "Strand"}, "name":
"strand"}]}, "name": "start"}, {"doc": "", "type": "long", "name":
"length"}]}, "type": "array"}, "name": "segments"}]}, "name":
"path"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "path",
        "variantSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'path': Path,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'path': Path,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['id', 'path', 'variantSetId']

    def __init__(self):
        self.id = None
        self.path = None
        self.variantSetId = None


class AlleleCall(ProtocolElement):
    """
An `AlleleCall` represents the determination of the copy number of a particular
`Allele`, possibly within a certain `Variant`.

It may include associated information such as quality and phasing.

The `Allele` copy numbers described by an `AlleleCall` must be consistent with
those implied by the `genotype`s of any `Call`s in the same `CallSet`. If a
server supports "graph" mode, it must provide `Variant`-associated `AlleleCall`s
for any `Variant` with a `Call` in the `CallSet`.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"AlleleCall", "fields": [{"doc": "", "type": "string", "name":
"callSetId"}, {"doc": "", "type": "string", "name": "alleleId"},
{"doc": "", "type": ["null", "string"], "name": "variantId"}, {"doc":
"", "type": "double", "name": "totalCopies"}, {"doc": "", "type":
{"items": "string", "type": "array"}, "name": "phaseset"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "alleleId",
        "callSetId",
        "phaseset",
        "totalCopies",
        "variantId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['alleleId', 'callSetId', 'info', 'phaseset', 'totalCopies',
                 'variantId']

    def __init__(self):
        self.alleleId = None
        self.callSetId = None
        self.info = {}
        self.phaseset = None
        self.totalCopies = None
        self.variantId = None


class Analysis(ProtocolElement):
    """
An analysis contains an interpretation of one or several experiments.
(e.g. SNVs, copy number variations, methylation status) together with
information about the methodology used.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Analysis", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "created"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "updated"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "type"}, {"default": null, "doc":
"", "type": {"items": "string", "type": "array"}, "name": "software"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set(["id"])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['created', 'description', 'id', 'info', 'name', 'software',
                 'type', 'updated']

    def __init__(self):
        self.created = None
        self.description = None
        self.id = None
        self.info = {}
        self.name = None
        self.software = None
        self.type = None
        self.updated = None


class Attributes(ProtocolElement):
    """
Type defining a collection of attributes associated with various protocol
  records.  Each attribute is a name that maps to an array of one or more
  values.  Values can be strings, external identifiers, or ontology terms.
  Values should be split into the array elements instead of using a separator
  syntax that needs to parsed.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Attributes", "fields": [{"default": {}, "type": {"values": {"items":
["string", {"doc": "", "type": "record", "name": "ExternalIdentifier",
"fields": [{"doc": "", "type": "string", "name": "database"}, {"doc":
"", "type": "string", "name": "identifier"}, {"doc": "", "type":
"string", "name": "version"}]}, {"doc": "", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"ontologySource"}, {"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}]}], "type": "array"}, "type": "map"}, "name": "vals"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['vals']

    def __init__(self):
        self.vals = {}


class BeaconInformationResource(ProtocolElement):
    """
BeaconInformationResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"BeaconInformationResource", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"doc": "", "type": "string", "name": "organization"},
{"doc": "", "type": "string", "name": "description"}, {"default": [],
"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"DataSetResource", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "reference"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"},
{"default": null, "doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "DataSizeResource", "fields": [{"doc": "", "type":
"int", "name": "variants"}, {"doc": "", "type": "int", "name":
"samples"}]}], "name": "size"}, {"doc": "", "type": "boolean", "name":
"multiple"}, {"default": [], "doc": "", "type": {"items": "string",
"type": "array"}, "name": "datasets"}, {"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name":
"DataUseResource", "fields": [{"doc": "", "type": "string", "name":
"category"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}, {"default": [], "doc": "", "type": {"items":
{"doc": "", "type": "record", "name": "DataUseRequirementResource",
"fields": [{"doc": "", "type": "string", "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"}]},
"type": "array"}, "name": "requirements"}]}, "type": "array"}, "name":
"data_use"}]}, "type": "array"}, "name": "datasets"}, {"doc": "",
"type": "string", "name": "api"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "homepage"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "email"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "auth"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "queries"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "api",
        "description",
        "id",
        "organization",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': DataSetResource,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': DataSetResource,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['api', 'auth', 'datasets', 'description', 'email', 'homepage',
                 'id', 'organization', 'queries']

    def __init__(self):
        self.api = None
        self.auth = None
        self.datasets = []
        self.description = None
        self.email = None
        self.homepage = None
        self.id = None
        self.organization = None
        self.queries = None


class BeaconResponseResource(ProtocolElement):
    """
The response from the Beacon
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"BeaconResponseResource", "fields": [{"doc": "", "type": "string",
"name": "beacon"}, {"doc": "", "type": {"doc": "", "type": "record",
"name": "QueryResource", "fields": [{"doc": "", "type": "string",
"name": "referenceBases"}, {"doc": "", "type": "string", "name":
"alternateBases"}, {"doc": "", "type": "string", "name":
"chromosome"}, {"doc": "", "type": "long", "name": "position"},
{"doc": "", "type": "string", "name": "reference"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "dataset"}]}, "name":
"query"}, {"doc": "", "type": {"doc": "", "type": "record", "name":
"ResponseResource", "fields": [{"doc": "", "type": "string", "name":
"exists"}, {"doc": "", "type": ["null", "double"], "name":
"frequency"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "observed"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "info"}, {"default": null, "doc": "", "type":
["null", {"doc": "", "type": "record", "name": "ErrorResource",
"fields": [{"doc": "", "type": "string", "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"description"}]}], "name": "err"}]}, "name": "response"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "beacon",
        "query",
        "response",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'query': QueryResource,
            'response': ResponseResource,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'query': QueryResource,
            'response': ResponseResource,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['beacon', 'query', 'response']

    def __init__(self):
        self.beacon = None
        self.query = None
        self.response = None


class Call(ProtocolElement):
    """
A `Call` represents the determination of genotype with respect to a
particular `Variant`.

It may include associated information such as quality
and phasing. For example, a call might assign a probability of 0.32 to
the occurrence of a SNP named rs1234 in a call set with the name NA12345.

The genotypes described by `Call`s must be consistent with any `AlleleCall`s in
the same `CallSet`. If a server supports "classic" mode, it must provide `Call`s
for all `Variant`s that have associated `AlleleCall`s in the `CallSet`.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Call",
"fields": [{"doc": "", "type": ["null", "string"], "name":
"callSetId"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "callSetName"}, {"doc": "", "type": ["null", "string"],
"name": "variantId"}, {"default": [], "doc": "", "type": {"items":
"int", "type": "array"}, "name": "genotype"}, {"default": null, "doc":
"", "type": ["null", "string", {"items": "string", "type": "array"}],
"name": "phaseset"}, {"default": [], "doc": "", "type": {"items":
"double", "type": "array"}, "name": "genotypeLikelihood"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "callSetId",
        "variantId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['callSetId', 'callSetName', 'genotype', 'genotypeLikelihood',
                 'info', 'phaseset', 'variantId']

    def __init__(self):
        self.callSetId = None
        self.callSetName = None
        self.genotype = []
        self.genotypeLikelihood = []
        self.info = {}
        self.phaseset = None
        self.variantId = None


class CallSet(ProtocolElement):
    """
A `CallSet` is a collection of variant calls for a particular sample.
It belongs to a `VariantSet`. This is equivalent to one column in VCF.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "CallSet",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "name"}, {"doc":
"", "type": ["null", "string"], "name": "sampleId"}, {"default": [],
"doc": "", "type": {"items": "string", "type": "array"}, "name":
"variantSetIds"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "created"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "updated"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "sampleId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['created', 'id', 'info', 'name', 'sampleId', 'updated',
                 'variantSetIds']

    def __init__(self):
        self.created = None
        self.id = None
        self.info = {}
        self.name = None
        self.sampleId = None
        self.updated = None
        self.variantSetIds = []


class CigarOperation(object):
    """
An enum for the different types of CIGAR alignment operations that exist.
Used wherever CIGAR alignments are used. The different enumerated values
have the following usage:

* `ALIGNMENT_MATCH`: An alignment match indicates that a sequence can be
  aligned to the reference without evidence of an INDEL. Unlike the
  `SEQUENCE_MATCH` and `SEQUENCE_MISMATCH` operators, the `ALIGNMENT_MATCH`
  operator does not indicate whether the reference and read sequences are an
  exact match. This operator is equivalent to SAM's `M`.
* `INSERT`: The insert operator indicates that the read contains evidence of
  bases being inserted into the reference. This operator is equivalent to
  SAM's `I`.
* `DELETE`: The delete operator indicates that the read contains evidence of
  bases being deleted from the reference. This operator is equivalent to
  SAM's `D`.
* `SKIP`: The skip operator indicates that this read skips a long segment of
  the reference, but the bases have not been deleted. This operator is
  commonly used when working with RNA-seq data, where reads may skip long
  segments of the reference between exons. This operator is equivalent to
  SAM's 'N'.
* `CLIP_SOFT`: The soft clip operator indicates that bases at the start/end
  of a read have not been considered during alignment. This may occur if the
  majority of a read maps, except for low quality bases at the start/end of
  a read. This operator is equivalent to SAM's 'S'. Bases that are soft clipped
  will still be stored in the read.
* `CLIP_HARD`: The hard clip operator indicates that bases at the start/end of
  a read have been omitted from this alignment. This may occur if this linear
  alignment is part of a chimeric alignment, or if the read has been trimmed
  (e.g., during error correction, or to trim poly-A tails for RNA-seq). This
  operator is equivalent to SAM's 'H'.
* `PAD`: The pad operator indicates that there is padding in an alignment.
  This operator is equivalent to SAM's 'P'.
* `SEQUENCE_MATCH`: This operator indicates that this portion of the aligned
  sequence exactly matches the reference (e.g., all bases are equal to the
  reference bases). This operator is equivalent to SAM's '='.
* `SEQUENCE_MISMATCH`: This operator indicates that this portion of the
  aligned sequence is an alignment match to the reference, but a sequence
  mismatch (e.g., the bases are not equal to the reference). This can
  indicate a SNP or a read error. This operator is equivalent to SAM's 'X'.
    """
    ALIGNMENT_MATCH = "ALIGNMENT_MATCH"
    INSERT = "INSERT"
    DELETE = "DELETE"
    SKIP = "SKIP"
    CLIP_SOFT = "CLIP_SOFT"
    CLIP_HARD = "CLIP_HARD"
    PAD = "PAD"
    SEQUENCE_MATCH = "SEQUENCE_MATCH"
    SEQUENCE_MISMATCH = "SEQUENCE_MISMATCH"


class CigarUnit(ProtocolElement):
    """
A structure for an instance of a CIGAR operation.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"CigarUnit", "fields": [{"doc": "", "type": {"symbols":
["ALIGNMENT_MATCH", "INSERT", "DELETE", "SKIP", "CLIP_SOFT",
"CLIP_HARD", "PAD", "SEQUENCE_MATCH", "SEQUENCE_MISMATCH"], "doc": "",
"type": "enum", "name": "CigarOperation"}, "name": "operation"},
{"doc": "", "type": "long", "name": "operationLength"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"referenceSequence"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "operation",
        "operationLength",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['operation', 'operationLength', 'referenceSequence']

    def __init__(self):
        self.operation = None
        self.operationLength = None
        self.referenceSequence = None


class DataSetResource(ProtocolElement):
    """
DataSetResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"DataSetResource", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "reference"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"},
{"default": null, "doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "DataSizeResource", "fields": [{"doc": "", "type":
"int", "name": "variants"}, {"doc": "", "type": "int", "name":
"samples"}]}], "name": "size"}, {"doc": "", "type": "boolean", "name":
"multiple"}, {"default": [], "doc": "", "type": {"items": "string",
"type": "array"}, "name": "datasets"}, {"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name":
"DataUseResource", "fields": [{"doc": "", "type": "string", "name":
"category"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}, {"default": [], "doc": "", "type": {"items":
{"doc": "", "type": "record", "name": "DataUseRequirementResource",
"fields": [{"doc": "", "type": "string", "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"}]},
"type": "array"}, "name": "requirements"}]}, "type": "array"}, "name":
"data_use"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "multiple",
        "reference",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'data_use': DataUseResource,
            'size': DataSizeResource,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'data_use': DataUseResource,
            'size': DataSizeResource,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['data_use', 'datasets', 'description', 'id', 'multiple',
                 'reference', 'size']

    def __init__(self):
        self.data_use = []
        self.datasets = []
        self.description = None
        self.id = None
        self.multiple = None
        self.reference = None
        self.size = None


class DataSizeResource(ProtocolElement):
    """
DataSetSizeResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"DataSizeResource", "fields": [{"doc": "", "type": "int", "name":
"variants"}, {"doc": "", "type": "int", "name": "samples"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "samples",
        "variants",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['samples', 'variants']

    def __init__(self):
        self.samples = None
        self.variants = None


class DataUseRequirementResource(ProtocolElement):
    """
DataUseRequirementResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"DataUseRequirementResource", "fields": [{"doc": "", "type": "string",
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set(["name"])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['description', 'name']

    def __init__(self):
        self.description = None
        self.name = None


class DataUseResource(ProtocolElement):
    """
DataUseResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"DataUseResource", "fields": [{"doc": "", "type": "string", "name":
"category"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}, {"default": [], "doc": "", "type": {"items":
{"doc": "", "type": "record", "name": "DataUseRequirementResource",
"fields": [{"doc": "", "type": "string", "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"}]},
"type": "array"}, "name": "requirements"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set(["category"])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'requirements': DataUseRequirementResource,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'requirements': DataUseRequirementResource,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['category', 'description', 'requirements']

    def __init__(self):
        self.category = None
        self.description = None
        self.requirements = []


class Dataset(ProtocolElement):
    """
No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Dataset",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set(["id"])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['description', 'id']

    def __init__(self):
        self.description = None
        self.id = None


class ErrorResource(ProtocolElement):
    """
ErrorResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"ErrorResource", "fields": [{"doc": "", "type": "string", "name":
"name"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set(["name"])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['description', 'name']

    def __init__(self):
        self.description = None
        self.name = None


class Experiment(ProtocolElement):
    """
No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Experiment", "fields": [{"default": null, "doc": "", "type": ["null",
"string"], "name": "libraryId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "platformUnit"}, {"doc": "", "type":
["null", "string"], "name": "sequencingCenter"}, {"doc": "", "type":
["null", "string"], "name": "instrumentModel"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "instrumentModel",
        "sequencingCenter",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['instrumentModel', 'libraryId', 'platformUnit',
                 'sequencingCenter']

    def __init__(self):
        self.instrumentModel = None
        self.libraryId = None
        self.platformUnit = None
        self.sequencingCenter = None


class ExternalIdentifier(ProtocolElement):
    """
Identifier from a public database
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ExternalIdentifier", "fields": [{"doc": "", "type": "string", "name":
"database"}, {"doc": "", "type": "string", "name": "identifier"},
{"doc": "", "type": "string", "name": "version"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "database",
        "identifier",
        "version",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['database', 'identifier', 'version']

    def __init__(self):
        self.database = None
        self.identifier = None
        self.version = None


class Feature(ProtocolElement):
    """
Node in the annotation graph that annotates a contiguous region of a
  sequence.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Feature",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"doc": "",
"type": {"items": "string", "type": "array"}, "name": "parentIds"},
{"doc": "", "type": "string", "name": "featureSetId"}, {"doc": "",
"type": {"doc": "", "type": "record", "name": "Path", "fields":
[{"default": [], "doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "Segment", "fields": [{"doc": "", "type": {"doc":
"", "type": "record", "name": "Side", "fields": [{"doc": "", "type":
{"doc": "", "type": "record", "name": "Position", "fields":
[{"default": null, "doc": "", "type": ["null", "string"], "name":
"sequenceId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"doc": "", "type": "long",
"name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}]}, "name": "start"}, {"doc": "",
"type": "long", "name": "length"}]}, "type": "array"}, "name":
"segments"}]}, "name": "path"}, {"doc": "", "type": {"doc": "",
"type": "record", "name": "OntologyTerm", "fields": [{"doc": "",
"type": "string", "name": "ontologySource"}, {"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}]}, "name": "featureType"}, {"doc": "",
"type": {"doc": "", "type": "record", "name": "Attributes", "fields":
[{"default": {}, "type": {"values": {"items": ["string", {"doc": "",
"type": "record", "name": "ExternalIdentifier", "fields": [{"doc": "",
"type": "string", "name": "database"}, {"doc": "", "type": "string",
"name": "identifier"}, {"doc": "", "type": "string", "name":
"version"}]}, "OntologyTerm"], "type": "array"}, "type": "map"},
"name": "vals"}]}, "name": "attributes"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "attributes",
        "featureSetId",
        "featureType",
        "id",
        "parentIds",
        "path",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
            'featureType': OntologyTerm,
            'path': Path,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
            'featureType': OntologyTerm,
            'path': Path,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['attributes', 'featureSetId', 'featureType', 'id', 'parentIds',
                 'path']

    def __init__(self):
        self.attributes = None
        self.featureSetId = None
        self.featureType = None
        self.id = None
        self.parentIds = None
        self.path = None


class FeatureSet(ProtocolElement):
    """
No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"FeatureSet", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"datasetId"}, {"doc": "", "type": ["null", "string"], "name":
"referenceSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "sourceURI"}, {"doc": "", "type": {"doc":
"", "type": "record", "name": "Attributes", "fields": [{"default": {},
"type": {"values": {"items": ["string", {"doc": "", "type": "record",
"name": "ExternalIdentifier", "fields": [{"doc": "", "type": "string",
"name": "database"}, {"doc": "", "type": "string", "name":
"identifier"}, {"doc": "", "type": "string", "name": "version"}]},
{"doc": "", "type": "record", "name": "OntologyTerm", "fields":
[{"doc": "", "type": "string", "name": "ontologySource"}, {"doc": "",
"type": "string", "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}]}], "type": "array"}, "type":
"map"}, "name": "vals"}]}, "name": "attributes"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "attributes",
        "id",
        "referenceSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['attributes', 'datasetId', 'id', 'name', 'referenceSetId',
                 'sourceURI']

    def __init__(self):
        self.attributes = None
        self.datasetId = None
        self.id = None
        self.name = None
        self.referenceSetId = None
        self.sourceURI = None


class GAException(ProtocolElement):
    """
A general exception type.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "error", "name":
"GAException", "fields": [{"doc": "", "type": "string", "name":
"message"}, {"default": -1, "doc": "", "type": "int", "name":
"errorCode"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set(["message"])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['errorCode', 'message']

    def __init__(self):
        self.errorCode = -1
        self.message = None


class GetSequenceBasesRequest(ProtocolElement):
    """
The query parameters for a request to `GET /sequence/{id}`, for
example:

`GET /sequence/c95d4520-8c63-45f1-924d-6a9604a919fb?start=100&end=200`
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"GetSequenceBasesRequest", "fields": [{"default": 0, "doc": "",
"type": "long", "name": "start"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "end"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['end', 'pageToken', 'start']

    def __init__(self):
        self.end = None
        self.pageToken = None
        self.start = 0


class GetSequenceBasesResponse(ProtocolElement):
    """
The response from `GET /sequence/{id}` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"GetSequenceBasesResponse", "fields": [{"default": 0, "doc": "",
"type": "long", "name": "offset"}, {"doc": "", "type": "string",
"name": "sequence"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set(["sequence"])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['nextPageToken', 'offset', 'sequence']

    def __init__(self):
        self.nextPageToken = None
        self.offset = 0
        self.sequence = None


class GraphAlignment(ProtocolElement):
    """
A string-to-reference-graph alignment can be represented by one CIGAR string and
one `Path` through multiple `Reference`s, against which the CIGAR string is
interpreted.

Note that `Path`s in `GraphAlignment`s are restricted to visiting `Reference`s
and following reference adjacencies. If a read needs to be aligned to sequences
that are not present in a `ReferenceSet`, it needs to be aligned to a new
`ReferenceSet` with those sequences. If a read needs to follow adjacencies that
are not present in the `ReferenceSet` it's being aligned to, it should be
represented as a "chimeric" alignment, and should use multiple `ReadAlignment`s
and the supplementaryAlignment flag instead of a single `GraphAlignment`.

Some especially large deletions could be represented just as well as a large
deletion in the CIGAR string, or as a chimeric alignment.
    """
    _schemaSource = """ 
{"namespace": "org.ga4gh.models", "type": "record", "name":
"GraphAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Path", "fields": [{"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "Segment",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Side", "fields": [{"doc": "", "type": {"doc": "", "type": "record",
"name": "Position", "fields": [{"default": null, "doc": "", "type":
["null", "string"], "name": "sequenceId"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceName"}, {"doc": "",
"type": "long", "name": "position"}]}, "name": "base"}, {"doc": "",
"type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type":
"enum", "name": "Strand"}, "name": "strand"}]}, "name": "start"},
{"doc": "", "type": "long", "name": "length"}]}, "type": "array"},
"name": "segments"}]}, "name": "path"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "mappingQuality"}, {"default": [],
"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"CigarUnit", "fields": [{"doc": "", "type": {"symbols":
["ALIGNMENT_MATCH", "INSERT", "DELETE", "SKIP", "CLIP_SOFT",
"CLIP_HARD", "PAD", "SEQUENCE_MATCH", "SEQUENCE_MISMATCH"], "doc": "",
"type": "enum", "name": "CigarOperation"}, "name": "operation"},
{"doc": "", "type": "long", "name": "operationLength"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"referenceSequence"}]}, "type": "array"}, "name": "cigar"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set(["path"])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'path': Path,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'path': Path,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['cigar', 'mappingQuality', 'path']

    def __init__(self):
        self.cigar = []
        self.mappingQuality = None
        self.path = None


class Individual(ProtocolElement):
    """
An individual (or subject) typically corresponds to an individual
human or other organism.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Individual", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "groupIds"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "created"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "updated"},
{"default": null, "doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "OntologyTerm", "fields": [{"doc": "", "type":
"string", "name": "ontologySource"}, {"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}]}], "name": "species"}, {"default": null,
"doc": "", "type": ["null", "OntologyTerm"], "name": "sex"},
{"default": null, "doc": "", "type": ["null", "OntologyTerm"], "name":
"developmentalStage"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "dateOfBirth"}, {"default": [], "doc": "", "type":
{"items": "OntologyTerm", "type": "array"}, "name": "diseases"},
{"default": [], "doc": "", "type": {"items": "OntologyTerm", "type":
"array"}, "name": "phenotypes"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "stagingSystem"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "clinicalTreatment"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"strain"}, {"default": {}, "doc": "", "type": {"values": {"items":
"string", "type": "array"}, "type": "map"}, "name": "info"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set(["id"])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'developmentalStage': OntologyTerm,
            'diseases': OntologyTerm,
            'phenotypes': OntologyTerm,
            'sex': OntologyTerm,
            'species': OntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'developmentalStage': OntologyTerm,
            'diseases': OntologyTerm,
            'phenotypes': OntologyTerm,
            'sex': OntologyTerm,
            'species': OntologyTerm,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['clinicalTreatment', 'created', 'dateOfBirth', 'description',
                 'developmentalStage', 'diseases', 'groupIds',
                 'id', 'info', 'name', 'phenotypes', 'sex',
                 'species', 'stagingSystem', 'strain',
                 'updated']

    def __init__(self):
        self.clinicalTreatment = None
        self.created = None
        self.dateOfBirth = None
        self.description = None
        self.developmentalStage = None
        self.diseases = []
        self.groupIds = []
        self.id = None
        self.info = {}
        self.name = None
        self.phenotypes = []
        self.sex = None
        self.species = None
        self.stagingSystem = None
        self.strain = None
        self.updated = None


class IndividualGroup(ProtocolElement):
    """
Represents a group of individuals. (e.g. a trio)
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"IndividualGroup", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "created"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "updated"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "type"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set(["id"])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['created', 'description', 'id', 'info', 'name', 'type',
                 'updated']

    def __init__(self):
        self.created = None
        self.description = None
        self.id = None
        self.info = {}
        self.name = None
        self.type = None
        self.updated = None


class Join(ProtocolElement):
    """
A `Join` is simply a pair of `Side` objects. The are logically unordered (i.e.
swapping makes no difference), but we require a rank on the Sequences, and so
implicitly on the sides, so to avoid ambiguity we require that the side
for side1 is less than that for side2.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Join",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Side", "fields": [{"doc": "", "type": {"doc": "", "type": "record",
"name": "Position", "fields": [{"default": null, "doc": "", "type":
["null", "string"], "name": "sequenceId"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceName"}, {"doc": "",
"type": "long", "name": "position"}]}, "name": "base"}, {"doc": "",
"type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type":
"enum", "name": "Strand"}, "name": "strand"}]}, "name": "side1"},
{"doc": "", "type": "Side", "name": "side2"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "side1",
        "side2",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'side1': Side,
            'side2': Side,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'side1': Side,
            'side2': Side,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['side1', 'side2']

    def __init__(self):
        self.side1 = None
        self.side2 = None


class LinearAlignment(ProtocolElement):
    """
A linear alignment can be represented by one CIGAR string.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"LinearAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Side", "fields": [{"doc": "", "type": {"doc": "",
"type": "record", "name": "Position", "fields": [{"default": null,
"doc": "", "type": ["null", "string"], "name": "sequenceId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceName"}, {"doc": "", "type": "long", "name": "position"}]},
"name": "base"}, {"doc": "", "type": {"symbols": ["NEG_STRAND",
"POS_STRAND"], "doc": "", "type": "enum", "name": "Strand"}, "name":
"strand"}]}, "name": "position"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "mappingQuality"}, {"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "CigarUnit",
"fields": [{"doc": "", "type": {"symbols": ["ALIGNMENT_MATCH",
"INSERT", "DELETE", "SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD",
"SEQUENCE_MATCH", "SEQUENCE_MISMATCH"], "doc": "", "type": "enum",
"name": "CigarOperation"}, "name": "operation"}, {"doc": "", "type":
"long", "name": "operationLength"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSequence"}]}, "type":
"array"}, "name": "cigar"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set(["position"])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'position': Side,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'position': Side,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['cigar', 'mappingQuality', 'position']

    def __init__(self):
        self.cigar = []
        self.mappingQuality = None
        self.position = None


class ListReferenceBasesRequest(ProtocolElement):
    """
The query parameters for a request to `GET /references/{id}/bases`, for
example:

`GET /references/{id}/bases?start=100&end=200`
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ListReferenceBasesRequest", "fields": [{"default": 0, "doc": "",
"type": "long", "name": "start"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "end"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['end', 'pageToken', 'start']

    def __init__(self):
        self.end = None
        self.pageToken = None
        self.start = 0


class ListReferenceBasesResponse(ProtocolElement):
    """
The response from `GET /references/{id}/bases` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ListReferenceBasesResponse", "fields": [{"default": 0, "doc": "",
"type": "long", "name": "offset"}, {"doc": "", "type": "string",
"name": "sequence"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set(["sequence"])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['nextPageToken', 'offset', 'sequence']

    def __init__(self):
        self.nextPageToken = None
        self.offset = 0
        self.sequence = None


class OntologyTerm(ProtocolElement):
    """
An ontology term describing an attribute. (e.g. the phenotype attribute
'polydactyly' from HPO)
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"ontologySource"}, {"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "ontologySource",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['id', 'name', 'ontologySource']

    def __init__(self):
        self.id = None
        self.name = None
        self.ontologySource = None


class Path(ProtocolElement):
    """
A `Path` is an ordered list of `Segment`s. In general any contiguous path
through a sequence graph, with no novel adjacencies, can be represented by a
`Path`.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Path",
"fields": [{"default": [], "doc": "", "type": {"items": {"doc": "",
"type": "record", "name": "Segment", "fields": [{"doc": "", "type":
{"doc": "", "type": "record", "name": "Side", "fields": [{"doc": "",
"type": {"doc": "", "type": "record", "name": "Position", "fields":
[{"default": null, "doc": "", "type": ["null", "string"], "name":
"sequenceId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"doc": "", "type": "long",
"name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}]}, "name": "start"}, {"doc": "",
"type": "long", "name": "length"}]}, "type": "array"}, "name":
"segments"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'segments': Segment,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'segments': Segment,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['segments']

    def __init__(self):
        self.segments = []


class Position(ProtocolElement):
    """
A `Position` is an unoriented base in some already known sequence. A
`Position` is represented by a sequence name or ID, and a base number on that
sequence (0-based).
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Position", "fields": [{"default": null, "doc": "", "type": ["null",
"string"], "name": "sequenceId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceName"}, {"doc": "", "type":
"long", "name": "position"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set(["position"])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['position', 'referenceName', 'sequenceId']

    def __init__(self):
        self.position = None
        self.referenceName = None
        self.sequenceId = None


class Program(ProtocolElement):
    """
No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Program",
"fields": [{"default": null, "doc": "", "type": ["null", "string"],
"name": "commandLine"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "prevProgramId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "version"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['commandLine', 'id', 'name', 'prevProgramId', 'version']

    def __init__(self):
        self.commandLine = None
        self.id = None
        self.name = None
        self.prevProgramId = None
        self.version = None


class QueryResource(ProtocolElement):
    """
A request for information about a specific site
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"QueryResource", "fields": [{"doc": "", "type": "string", "name":
"referenceBases"}, {"doc": "", "type": "string", "name":
"alternateBases"}, {"doc": "", "type": "string", "name":
"chromosome"}, {"doc": "", "type": "long", "name": "position"},
{"doc": "", "type": "string", "name": "reference"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "dataset"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "alternateBases",
        "chromosome",
        "position",
        "reference",
        "referenceBases",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['alternateBases', 'chromosome', 'dataset', 'position',
                 'reference', 'referenceBases']

    def __init__(self):
        self.alternateBases = None
        self.chromosome = None
        self.dataset = None
        self.position = None
        self.reference = None
        self.referenceBases = None


class ReadAlignment(ProtocolElement):
    """
Each read alignment describes an alignment with additional information
about the fragment and the read. A read alignment object is equivalent to a
line in a SAM file.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadAlignment", "fields": [{"doc": "", "type": ["null", "string"],
"name": "id"}, {"doc": "", "type": "string", "name": "readGroupId"},
{"doc": "", "type": "string", "name": "fragmentName"}, {"default":
false, "doc": "", "type": ["boolean", "null"], "name":
"properPlacement"}, {"default": false, "doc": "", "type": ["boolean",
"null"], "name": "duplicateFragment"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "numberReads"}, {"default": null,
"doc": "", "type": ["null", "int"], "name": "fragmentLength"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"readNumber"}, {"default": false, "doc": "", "type": ["boolean",
"null"], "name": "failedVendorQualityChecks"}, {"default": null,
"doc": "", "type": ["null", {"doc": "", "type": "record", "name":
"LinearAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Side", "fields": [{"doc": "", "type": {"doc": "",
"type": "record", "name": "Position", "fields": [{"default": null,
"doc": "", "type": ["null", "string"], "name": "sequenceId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceName"}, {"doc": "", "type": "long", "name": "position"}]},
"name": "base"}, {"doc": "", "type": {"symbols": ["NEG_STRAND",
"POS_STRAND"], "doc": "", "type": "enum", "name": "Strand"}, "name":
"strand"}]}, "name": "position"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "mappingQuality"}, {"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "CigarUnit",
"fields": [{"doc": "", "type": {"symbols": ["ALIGNMENT_MATCH",
"INSERT", "DELETE", "SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD",
"SEQUENCE_MATCH", "SEQUENCE_MISMATCH"], "doc": "", "type": "enum",
"name": "CigarOperation"}, "name": "operation"}, {"doc": "", "type":
"long", "name": "operationLength"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSequence"}]}, "type":
"array"}, "name": "cigar"}]}, {"doc": "", "type": "record", "name":
"GraphAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Path", "fields": [{"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "Segment",
"fields": [{"doc": "", "type": "Side", "name": "start"}, {"doc": "",
"type": "long", "name": "length"}]}, "type": "array"}, "name":
"segments"}]}, "name": "path"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "mappingQuality"}, {"default": [], "doc": "",
"type": {"items": "CigarUnit", "type": "array"}, "name": "cigar"}]}],
"name": "alignment"}, {"default": false, "doc": "", "type":
["boolean", "null"], "name": "secondaryAlignment"}, {"default": false,
"doc": "", "type": ["boolean", "null"], "name":
"supplementaryAlignment"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "alignedSequence"}, {"default": [], "doc":
"", "type": {"items": "int", "type": "array"}, "name":
"alignedQuality"}, {"default": null, "doc": "", "type": ["null",
"Side"], "name": "nextMatePosition"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "fragmentName",
        "id",
        "readGroupId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignment': LinearAlignment,
            'nextMatePosition': Side,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignment': LinearAlignment,
            'nextMatePosition': Side,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['alignedQuality', 'alignedSequence', 'alignment',
                 'duplicateFragment',
                 'failedVendorQualityChecks',
                 'fragmentLength', 'fragmentName', 'id',
                 'info', 'nextMatePosition', 'numberReads',
                 'properPlacement', 'readGroupId',
                 'readNumber', 'secondaryAlignment',
                 'supplementaryAlignment']

    def __init__(self):
        self.alignedQuality = []
        self.alignedSequence = None
        self.alignment = None
        self.duplicateFragment = False
        self.failedVendorQualityChecks = False
        self.fragmentLength = None
        self.fragmentName = None
        self.id = None
        self.info = {}
        self.nextMatePosition = None
        self.numberReads = None
        self.properPlacement = False
        self.readGroupId = None
        self.readNumber = None
        self.secondaryAlignment = False
        self.supplementaryAlignment = False


class ReadGroup(ProtocolElement):
    """
No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadGroup", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"datasetId"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"doc": "", "type": ["null",
"string"], "name": "sampleId"}, {"doc": "", "type": ["null",
{"fields": [{"default": null, "doc": "", "type": ["null", "string"],
"name": "libraryId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "platformUnit"}, {"doc": "", "type": ["null",
"string"], "name": "sequencingCenter"}, {"doc": "", "type": ["null",
"string"], "name": "instrumentModel"}], "type": "record", "name":
"Experiment"}], "name": "experiment"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "predictedInsertSize"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "created"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"updated"}, {"default": null, "doc": "", "type": ["null", {"fields":
[{"default": null, "doc": "", "type": ["null", "long"], "name":
"alignedReadCount"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "unalignedReadCount"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "baseCount"}], "type": "record",
"name": "ReadStats"}], "name": "stats"}, {"default": [], "doc": "",
"type": {"items": {"fields": [{"default": null, "doc": "", "type":
["null", "string"], "name": "commandLine"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "id"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "prevProgramId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"version"}], "type": "record", "name": "Program"}, "type": "array"},
"name": "programs"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceSetId"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "experiment",
        "id",
        "sampleId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiment': Experiment,
            'programs': Program,
            'stats': ReadStats,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiment': Experiment,
            'programs': Program,
            'stats': ReadStats,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['created', 'datasetId', 'description', 'experiment', 'id',
                 'info', 'name', 'predictedInsertSize',
                 'programs', 'referenceSetId', 'sampleId',
                 'stats', 'updated']

    def __init__(self):
        self.created = None
        self.datasetId = None
        self.description = None
        self.experiment = None
        self.id = None
        self.info = {}
        self.name = None
        self.predictedInsertSize = None
        self.programs = []
        self.referenceSetId = None
        self.sampleId = None
        self.stats = None
        self.updated = None


class ReadGroupSet(ProtocolElement):
    """
No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadGroupSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "datasetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", {"fields": [{"default": null, "doc": "", "type": ["null",
"long"], "name": "alignedReadCount"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "unalignedReadCount"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "baseCount"}],
"type": "record", "name": "ReadStats"}], "name": "stats"}, {"default":
[], "doc": "", "type": {"items": {"fields": [{"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "datasetId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"doc": "",
"type": ["null", "string"], "name": "sampleId"}, {"doc": "", "type":
["null", {"fields": [{"default": null, "doc": "", "type": ["null",
"string"], "name": "libraryId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "platformUnit"}, {"doc": "", "type":
["null", "string"], "name": "sequencingCenter"}, {"doc": "", "type":
["null", "string"], "name": "instrumentModel"}], "type": "record",
"name": "Experiment"}], "name": "experiment"}, {"default": null,
"doc": "", "type": ["null", "int"], "name": "predictedInsertSize"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"created"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "updated"}, {"default": null, "doc": "", "type": ["null",
"ReadStats"], "name": "stats"}, {"default": [], "doc": "", "type":
{"items": {"fields": [{"default": null, "doc": "", "type": ["null",
"string"], "name": "commandLine"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "prevProgramId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"version"}], "type": "record", "name": "Program"}, "type": "array"},
"name": "programs"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceSetId"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "type": "record", "name": "ReadGroup"},
"type": "array"}, "name": "readGroups"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set(["id"])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroups': ReadGroup,
            'stats': ReadStats,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroups': ReadGroup,
            'stats': ReadStats,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['datasetId', 'id', 'name', 'readGroups', 'stats']

    def __init__(self):
        self.datasetId = None
        self.id = None
        self.name = None
        self.readGroups = []
        self.stats = None


class ReadStats(ProtocolElement):
    """
No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadStats", "fields": [{"default": null, "doc": "", "type": ["null",
"long"], "name": "alignedReadCount"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "unalignedReadCount"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "baseCount"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['alignedReadCount', 'baseCount', 'unalignedReadCount']

    def __init__(self):
        self.alignedReadCount = None
        self.baseCount = None
        self.unalignedReadCount = None


class Reference(ProtocolElement):
    """
A `Reference` is a canonical assembled contig, intended to act as a
reference coordinate space for other genomic annotations. A single
`Reference` might represent the human chromosome 1, for instance.

`Reference`s are designed to be immutable. When extending a `ReferenceSet` with
new `Reference`s, the existing `References` should not be changed. Newly added
`Reference` `Sequence`s may be children of existing `Reference` `Sequence`s, but
existing `Reference` `Sequence`s should not be made to be children of newly
added `Reference` `Sequence`s.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Reference", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": "string", "name": "sequenceId"}, {"doc": "",
"type": "long", "name": "start"}, {"doc": "", "type": "long", "name":
"length"}, {"doc": "", "type": "string", "name": "md5checksum"},
{"doc": "", "type": "string", "name": "name"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "sourceURI"}, {"doc":
"", "type": {"items": "string", "type": "array"}, "name":
"sourceAccessions"}, {"default": false, "doc": "", "type": "boolean",
"name": "isDerived"}, {"default": null, "doc": "", "type": ["null",
"float"], "name": "sourceDivergence"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "ncbiTaxonId"}, {"default": true,
"doc": "", "type": "boolean", "name": "isPrimary"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "length",
        "md5checksum",
        "name",
        "sequenceId",
        "sourceAccessions",
        "start",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['id', 'isDerived', 'isPrimary', 'length', 'md5checksum',
                 'name', 'ncbiTaxonId', 'sequenceId',
                 'sourceAccessions', 'sourceDivergence', 'start']

    def __init__(self):
        self.id = None
        self.isDerived = False
        self.isPrimary = True
        self.length = None
        self.md5checksum = None
        self.name = None
        self.ncbiTaxonId = None
        self.sequenceId = None
        self.sourceAccessions = None
        self.sourceDivergence = None
        self.start = None


class ReferenceSet(ProtocolElement):
    """
A `ReferenceSet` is a set of `Reference`s which typically comprise a
reference assembly, such as `GRCh38`. A `ReferenceSet` defines a common
coordinate space for comparing reference-aligned experimental data.

`ReferenceSet`s are composeable: a `ReferenceSet` may incorporate all of the
`Reference`s and `Join`s from one or more other `ReferenceSet`s via the
`includedReferenceSet`s array.

In classic mode, this is just a set of sequences.  In graph mode, there
are both sequences and joins, but we only access the joins via method
getReferenceJoins().
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReferenceSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", {"items":
"string", "type": "array"}], "name": "referenceIds"}, {"default":
null, "doc": "", "type": {"items": "string", "type": "array"}, "name":
"includedReferenceSets"}, {"doc": "", "type": "string", "name":
"md5checksum"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "ncbiTaxonId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "assemblyId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "sourceURI"}, {"doc":
"", "type": {"items": "string", "type": "array"}, "name":
"sourceAccessions"}, {"default": false, "doc": "", "type": "boolean",
"name": "isDerived"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "md5checksum",
        "sourceAccessions",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['assemblyId', 'description', 'id', 'includedReferenceSets',
                 'isDerived', 'md5checksum', 'ncbiTaxonId',
                 'referenceIds', 'sourceAccessions']

    def __init__(self):
        self.assemblyId = None
        self.description = None
        self.id = None
        self.includedReferenceSets = None
        self.isDerived = False
        self.md5checksum = None
        self.ncbiTaxonId = None
        self.referenceIds = None
        self.sourceAccessions = None


class Region(ProtocolElement):
    """
An abstraction for referring to a genomic region, in relation to some already 
known reference. This will require some significant rework as we move to graph
coordinates.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Region",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Position", "fields": [{"default": null, "doc": "", "type": ["null",
"string"], "name": "sequenceId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceName"}, {"doc": "", "type":
"long", "name": "position"}]}, "name": "start"}, {"doc": "", "type":
"long", "name": "length"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "length",
        "start",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'start': Position,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'start': Position,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['length', 'start']

    def __init__(self):
        self.length = None
        self.start = None


class ResponseResource(ProtocolElement):
    """
The response to the Beacon query
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"ResponseResource", "fields": [{"doc": "", "type": "string", "name":
"exists"}, {"doc": "", "type": ["null", "double"], "name":
"frequency"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "observed"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "info"}, {"default": null, "doc": "", "type":
["null", {"doc": "", "type": "record", "name": "ErrorResource",
"fields": [{"doc": "", "type": "string", "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"description"}]}], "name": "err"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "exists",
        "frequency",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'err': ErrorResource,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'err': ErrorResource,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['err', 'exists', 'frequency', 'info', 'observed']

    def __init__(self):
        self.err = None
        self.exists = None
        self.frequency = None
        self.info = None
        self.observed = None


class Sample(ProtocolElement):
    """
A biological sample used in an experiment. (e.g. whole blood from
an affected individual)
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Sample",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "individualId"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "accessions"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "created"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "updated"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"samplingDate"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "age"}, {"default": null, "doc": "", "type": ["null",
{"doc": "", "type": "record", "name": "OntologyTerm", "fields":
[{"doc": "", "type": "string", "name": "ontologySource"}, {"doc": "",
"type": "string", "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}]}], "name": "cellType"},
{"default": null, "doc": "", "type": ["null", "OntologyTerm"], "name":
"cellLine"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "geocode"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "sampleType"}, {"default": null, "doc": "", "type":
["null", "OntologyTerm"], "name": "organismPart"}, {"default": {},
"doc": "", "type": {"values": {"items": "string", "type": "array"},
"type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set(["id"])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cellLine': OntologyTerm,
            'cellType': OntologyTerm,
            'organismPart': OntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cellLine': OntologyTerm,
            'cellType': OntologyTerm,
            'organismPart': OntologyTerm,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['accessions', 'age', 'cellLine', 'cellType', 'created',
                 'description', 'geocode', 'id',
                 'individualId', 'info', 'name',
                 'organismPart', 'sampleType', 'samplingDate',
                 'updated']

    def __init__(self):
        self.accessions = []
        self.age = None
        self.cellLine = None
        self.cellType = None
        self.created = None
        self.description = None
        self.geocode = None
        self.id = None
        self.individualId = None
        self.info = {}
        self.name = None
        self.organismPart = None
        self.sampleType = None
        self.samplingDate = None
        self.updated = None


class SearchAlleleCallsRequest(SearchRequest):
    """
This request maps to the body of `POST /allelecalls/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchAlleleCallsRequest", "fields": [{"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "callSetIds"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "variantSetIds"}, {"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "alleleIds"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "variantIds"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "pageSize"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['alleleIds', 'callSetIds', 'pageSize', 'pageToken',
                 'variantIds', 'variantSetIds']

    def __init__(self):
        self.alleleIds = []
        self.callSetIds = []
        self.pageSize = None
        self.pageToken = None
        self.variantIds = []
        self.variantSetIds = []


class SearchAlleleCallsResponse(SearchResponse):
    """
This is the response from `POST /allelecalls/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchAlleleCallsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "AlleleCall", "fields": [{"doc": "", "type": "string", "name":
"callSetId"}, {"doc": "", "type": "string", "name": "alleleId"},
{"doc": "", "type": ["null", "string"], "name": "variantId"}, {"doc":
"", "type": "double", "name": "totalCopies"}, {"doc": "", "type":
{"items": "string", "type": "array"}, "name": "phaseset"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}, "type":
"array"}, "name": "alleleCalls"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "alleleCalls"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alleleCalls': AlleleCall,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alleleCalls': AlleleCall,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['alleleCalls', 'nextPageToken']

    def __init__(self):
        self.alleleCalls = []
        self.nextPageToken = None


class SearchAllelesRequest(SearchRequest):
    """
This request maps to the body of `POST /alleles/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchAllelesRequest", "fields": [{"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "variantSetIds"},
{"doc": "", "type": "string", "name": "sequenceId"}, {"doc": "",
"type": "long", "name": "start"}, {"doc": "", "type": "long", "name":
"end"}, {"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "end",
        "sequenceId",
        "start",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['end', 'pageSize', 'pageToken', 'sequenceId', 'start',
                 'variantSetIds']

    def __init__(self):
        self.end = None
        self.pageSize = None
        self.pageToken = None
        self.sequenceId = None
        self.start = None
        self.variantSetIds = []


class SearchAllelesResponse(SearchResponse):
    """
This is the response from `POST /alleles/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchAllelesResponse", "fields": [{"default": [], "doc": "", "type":
{"items": {"namespace": "org.ga4gh.models", "type": "record", "name":
"Allele", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": "string", "name": "variantSetId"}, {"doc": "",
"type": {"doc": "", "type": "record", "name": "Path", "fields":
[{"default": [], "doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "Segment", "fields": [{"doc": "", "type": {"doc":
"", "type": "record", "name": "Side", "fields": [{"doc": "", "type":
{"doc": "", "type": "record", "name": "Position", "fields":
[{"default": null, "doc": "", "type": ["null", "string"], "name":
"sequenceId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"doc": "", "type": "long",
"name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}]}, "name": "start"}, {"doc": "",
"type": "long", "name": "length"}]}, "type": "array"}, "name":
"segments"}]}, "name": "path"}], "doc": ""}, "type": "array"}, "name":
"alleles"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "alleles"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alleles': Allele,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alleles': Allele,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['alleles', 'nextPageToken']

    def __init__(self):
        self.alleles = []
        self.nextPageToken = None


class SearchAnalysesRequest(SearchRequest):
    """
This request maps to the body of `POST /analyses/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchAnalysesRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "name"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "pageSize"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "pageToken"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['name', 'pageSize', 'pageToken']

    def __init__(self):
        self.name = None
        self.pageSize = None
        self.pageToken = None


class SearchAnalysesResponse(SearchResponse):
    """
This is the response from `POST /analyses/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchAnalysesResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Analysis", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "created"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "updated"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "type"}, {"default":
null, "doc": "", "type": {"items": "string", "type": "array"}, "name":
"software"}, {"default": {}, "doc": "", "type": {"values": {"items":
"string", "type": "array"}, "type": "map"}, "name": "info"}], "doc":
""}, "type": "array"}, "name": "analyses"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "analyses"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'analyses': Analysis,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'analyses': Analysis,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['analyses', 'nextPageToken']

    def __init__(self):
        self.analyses = []
        self.nextPageToken = None


class SearchCallSetsRequest(SearchRequest):
    """
This request maps to the body of `POST /callsets/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchCallSetsRequest", "fields": [{"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "variantSetIds"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['name', 'pageSize', 'pageToken', 'variantSetIds']

    def __init__(self):
        self.name = None
        self.pageSize = None
        self.pageToken = None
        self.variantSetIds = []


class SearchCallSetsResponse(SearchResponse):
    """
This is the response from `POST /callsets/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchCallSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "CallSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"doc": "", "type": ["null", "string"], "name":
"sampleId"}, {"default": [], "doc": "", "type": {"items": "string",
"type": "array"}, "name": "variantSetIds"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "created"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "updated"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}, "type":
"array"}, "name": "callSets"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "callSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'callSets': CallSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'callSets': CallSet,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['callSets', 'nextPageToken']

    def __init__(self):
        self.callSets = []
        self.nextPageToken = None


class SearchCallsRequest(SearchRequest):
    """
This request maps to the body of `POST /calls/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchCallsRequest", "fields": [{"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "callSetIds"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "variantSetIds"}, {"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "variantIds"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['callSetIds', 'pageSize', 'pageToken', 'variantIds',
                 'variantSetIds']

    def __init__(self):
        self.callSetIds = []
        self.pageSize = None
        self.pageToken = None
        self.variantIds = []
        self.variantSetIds = []


class SearchCallsResponse(SearchResponse):
    """
This is the response from `POST /calls/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchCallsResponse", "fields": [{"default": [], "doc": "", "type":
{"items": {"namespace": "org.ga4gh.models", "type": "record", "name":
"Call", "fields": [{"doc": "", "type": ["null", "string"], "name":
"callSetId"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "callSetName"}, {"doc": "", "type": ["null", "string"],
"name": "variantId"}, {"default": [], "doc": "", "type": {"items":
"int", "type": "array"}, "name": "genotype"}, {"default": null, "doc":
"", "type": ["null", "string", {"items": "string", "type": "array"}],
"name": "phaseset"}, {"default": [], "doc": "", "type": {"items":
"double", "type": "array"}, "name": "genotypeLikelihood"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}, "type":
"array"}, "name": "calls"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "calls"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'calls': Call,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'calls': Call,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['calls', 'nextPageToken']

    def __init__(self):
        self.calls = []
        self.nextPageToken = None


class SearchDatasetsRequest(SearchRequest):
    """
This request maps to the body of `POST /datasets/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchDatasetsRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "int"], "name": "pageSize"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['pageSize', 'pageToken']

    def __init__(self):
        self.pageSize = None
        self.pageToken = None


class SearchDatasetsResponse(SearchResponse):
    """
This is the response from `POST /datasets/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchDatasetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Dataset", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}]}, "type": "array"}, "name": "datasets"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "datasets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': Dataset,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': Dataset,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['datasets', 'nextPageToken']

    def __init__(self):
        self.datasets = []
        self.nextPageToken = None


class SearchExperimentsRequest(SearchRequest):
    """
This request maps to the body of `POST /experiments/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchExperimentsRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "name"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "pageSize"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "pageToken"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['name', 'pageSize', 'pageToken']

    def __init__(self):
        self.name = None
        self.pageSize = None
        self.pageToken = None


class SearchExperimentsResponse(SearchResponse):
    """
This is the response from `POST /experiments/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchExperimentsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Experiment", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "created"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "updated"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "runDate"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "molecule"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"strategy"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "selection"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "library"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "libraryLayout"}, {"doc": "", "type":
["null", "string"], "name": "instrumentModel"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "instrumentDataFile"},
{"doc": "", "type": ["null", "string"], "name": "sequencingCenter"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"platformUnit"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name":
"info"}], "doc": ""}, "type": "array"}, "name": "experiments"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "experiments"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiments': Experiment,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiments': Experiment,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['experiments', 'nextPageToken']

    def __init__(self):
        self.experiments = []
        self.nextPageToken = None


class SearchFeaturesRequest(SearchRequest):
    """
This request maps to the body of `POST /features/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchFeaturesRequest", "fields": [{"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "featureSetIds"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "parentIds"}, {"default": null, "doc": "", "type":
["null", {"namespace": "org.ga4gh.models", "type": "record", "name":
"Path", "fields": [{"default": [], "doc": "", "type": {"items":
{"doc": "", "type": "record", "name": "Segment", "fields": [{"doc":
"", "type": {"doc": "", "type": "record", "name": "Side", "fields":
[{"doc": "", "type": {"doc": "", "type": "record", "name": "Position",
"fields": [{"default": null, "doc": "", "type": ["null", "string"],
"name": "sequenceId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"doc": "", "type": "long",
"name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}]}, "name": "start"}, {"doc": "",
"type": "long", "name": "length"}]}, "type": "array"}, "name":
"segments"}], "doc": ""}], "name": "range"}, {"default": [], "doc":
"", "type": {"items": {"namespace": "org.ga4gh.models", "type":
"record", "name": "OntologyTerm", "fields": [{"doc": "", "type":
"string", "name": "ontologySource"}, {"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}], "doc": ""}, "type": "array"}, "name":
"features"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "pageSize"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': OntologyTerm,
            'range': Path,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': OntologyTerm,
            'range': Path,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['featureSetIds', 'features', 'pageSize', 'pageToken',
                 'parentIds', 'range']

    def __init__(self):
        self.featureSetIds = []
        self.features = []
        self.pageSize = None
        self.pageToken = None
        self.parentIds = []
        self.range = None


class SearchFeaturesResponse(SearchResponse):
    """
This is the response from `POST /features/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchFeaturesResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Feature", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": {"items": "string", "type": "array"},
"name": "parentIds"}, {"doc": "", "type": "string", "name":
"featureSetId"}, {"doc": "", "type": {"doc": "", "type": "record",
"name": "Path", "fields": [{"default": [], "doc": "", "type":
{"items": {"doc": "", "type": "record", "name": "Segment", "fields":
[{"doc": "", "type": {"doc": "", "type": "record", "name": "Side",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Position", "fields": [{"default": null, "doc": "", "type": ["null",
"string"], "name": "sequenceId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceName"}, {"doc": "", "type":
"long", "name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}]}, "name": "start"}, {"doc": "",
"type": "long", "name": "length"}]}, "type": "array"}, "name":
"segments"}]}, "name": "path"}, {"doc": "", "type": {"doc": "",
"type": "record", "name": "OntologyTerm", "fields": [{"doc": "",
"type": "string", "name": "ontologySource"}, {"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}]}, "name": "featureType"}, {"doc": "",
"type": {"doc": "", "type": "record", "name": "Attributes", "fields":
[{"default": {}, "type": {"values": {"items": ["string", {"doc": "",
"type": "record", "name": "ExternalIdentifier", "fields": [{"doc": "",
"type": "string", "name": "database"}, {"doc": "", "type": "string",
"name": "identifier"}, {"doc": "", "type": "string", "name":
"version"}]}, "OntologyTerm"], "type": "array"}, "type": "map"},
"name": "vals"}]}, "name": "attributes"}], "doc": ""}, "type":
"array"}, "name": "features"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "features"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': Feature,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': Feature,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['features', 'nextPageToken']

    def __init__(self):
        self.features = []
        self.nextPageToken = None


class SearchIndividualGroupsRequest(SearchRequest):
    """
This request maps to the body of `POST /individualgroups/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchIndividualGroupsRequest", "fields": [{"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}, {"default": null,
"doc": "", "type": ["null", "int"], "name": "pageSize"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "pageToken"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['name', 'pageSize', 'pageToken']

    def __init__(self):
        self.name = None
        self.pageSize = None
        self.pageToken = None


class SearchIndividualGroupsResponse(SearchResponse):
    """
This is the response from `POST /individualgroups/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchIndividualGroupsResponse", "fields": [{"default": [], "doc":
"", "type": {"items": {"namespace": "org.ga4gh.models", "type":
"record", "name": "IndividualGroup", "fields": [{"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "description"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "created"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "updated"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "type"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}], "doc": ""},
"type": "array"}, "name": "individualGroups"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "nextPageToken"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "individualGroups"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'individualGroups': IndividualGroup,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'individualGroups': IndividualGroup,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['individualGroups', 'nextPageToken']

    def __init__(self):
        self.individualGroups = []
        self.nextPageToken = None


class SearchIndividualsRequest(SearchRequest):
    """
This request maps to the body of `POST /individuals/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchIndividualsRequest", "fields": [{"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "groupIds"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['groupIds', 'name', 'pageSize', 'pageToken']

    def __init__(self):
        self.groupIds = []
        self.name = None
        self.pageSize = None
        self.pageToken = None


class SearchIndividualsResponse(SearchResponse):
    """
This is the response from `POST /individuals/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchIndividualsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Individual", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "groupIds"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "created"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "updated"},
{"default": null, "doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "OntologyTerm", "fields": [{"doc": "", "type":
"string", "name": "ontologySource"}, {"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}]}], "name": "species"}, {"default": null,
"doc": "", "type": ["null", "OntologyTerm"], "name": "sex"},
{"default": null, "doc": "", "type": ["null", "OntologyTerm"], "name":
"developmentalStage"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "dateOfBirth"}, {"default": [], "doc": "", "type":
{"items": "OntologyTerm", "type": "array"}, "name": "diseases"},
{"default": [], "doc": "", "type": {"items": "OntologyTerm", "type":
"array"}, "name": "phenotypes"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "stagingSystem"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "clinicalTreatment"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"strain"}, {"default": {}, "doc": "", "type": {"values": {"items":
"string", "type": "array"}, "type": "map"}, "name": "info"}], "doc":
""}, "type": "array"}, "name": "individuals"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "nextPageToken"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "individuals"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'individuals': Individual,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'individuals': Individual,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['individuals', 'nextPageToken']

    def __init__(self):
        self.individuals = []
        self.nextPageToken = None


class SearchJoinsRequest(SearchRequest):
    """
This request maps to the body of `POST /joins/search` as JSON. Specifies a
number of filters, all of which must be satisfied by each result returned.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchJoinsRequest", "fields": [{"default": null, "doc": "", "type":
["null", "string"], "name": "referenceSetId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "variantSetId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"sequenceId"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "start"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "length"}, {"default": null, "doc": "", "type":
["null", {"symbols": ["NEG_STRAND", "POS_STRAND"], "namespace":
"org.ga4gh.models", "type": "enum", "name": "Strand", "doc": ""}],
"name": "strand"}, {"default": null, "doc": "", "type": ["null",
"int"], "name": "pageSize"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['length', 'pageSize', 'pageToken', 'referenceSetId',
                 'sequenceId', 'start', 'strand',
                 'variantSetId']

    def __init__(self):
        self.length = None
        self.pageSize = None
        self.pageToken = None
        self.referenceSetId = None
        self.sequenceId = None
        self.start = None
        self.strand = None
        self.variantSetId = None


class SearchJoinsResponse(SearchResponse):
    """
This is the response from `POST /joins/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchJoinsResponse", "fields": [{"default": [], "doc": "", "type":
{"items": {"namespace": "org.ga4gh.models", "type": "record", "name":
"Join", "fields": [{"doc": "", "type": {"doc": "", "type": "record",
"name": "Side", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Position", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "sequenceId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "referenceName"},
{"doc": "", "type": "long", "name": "position"}]}, "name": "base"},
{"doc": "", "type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc":
"", "type": "enum", "name": "Strand"}, "name": "strand"}]}, "name":
"side1"}, {"doc": "", "type": "Side", "name": "side2"}], "doc": ""},
"type": "array"}, "name": "joins"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "joins"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'joins': Join,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'joins': Join,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['joins', 'nextPageToken']

    def __init__(self):
        self.joins = []
        self.nextPageToken = None


class SearchReadGroupSetsRequest(SearchRequest):
    """
This request maps to the body of `POST /readgroupsets/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadGroupSetsRequest", "fields": [{"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "datasetIds"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['datasetIds', 'name', 'pageSize', 'pageToken']

    def __init__(self):
        self.datasetIds = []
        self.name = None
        self.pageSize = None
        self.pageToken = None


class SearchReadGroupSetsResponse(SearchResponse):
    """
This is the response from `POST /readgroupsets/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadGroupSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "ReadGroupSet", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "datasetId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", {"fields": [{"default": null, "doc": "", "type":
["null", "long"], "name": "alignedReadCount"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "unalignedReadCount"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"baseCount"}], "type": "record", "name": "ReadStats"}], "name":
"stats"}, {"default": [], "doc": "", "type": {"items": {"fields":
[{"doc": "", "type": "string", "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "datasetId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "name"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"description"}, {"doc": "", "type": ["null", "string"], "name":
"sampleId"}, {"doc": "", "type": ["null", {"fields": [{"default":
null, "doc": "", "type": ["null", "string"], "name": "libraryId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"platformUnit"}, {"doc": "", "type": ["null", "string"], "name":
"sequencingCenter"}, {"doc": "", "type": ["null", "string"], "name":
"instrumentModel"}], "type": "record", "name": "Experiment"}], "name":
"experiment"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "predictedInsertSize"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "created"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "updated"}, {"default": null, "doc":
"", "type": ["null", "ReadStats"], "name": "stats"}, {"default": [],
"doc": "", "type": {"items": {"fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "commandLine"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "name"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"prevProgramId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "version"}], "type": "record", "name": "Program"},
"type": "array"}, "name": "programs"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSetId"}, {"default": {},
"doc": "", "type": {"values": {"items": "string", "type": "array"},
"type": "map"}, "name": "info"}], "type": "record", "name":
"ReadGroup"}, "type": "array"}, "name": "readGroups"}]}, "type":
"array"}, "name": "readGroupSets"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "readGroupSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroupSets': ReadGroupSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroupSets': ReadGroupSet,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['nextPageToken', 'readGroupSets']

    def __init__(self):
        self.nextPageToken = None
        self.readGroupSets = []


class SearchReadsRequest(SearchRequest):
    """
This request maps to the body of `POST /reads/search` as JSON.

If a reference is specified, all queried `ReadGroup`s must be aligned
to `ReferenceSet`s containing that same `Reference`. If no reference is
specified, all `ReadGroup`s must be aligned to the same `ReferenceSet`.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadsRequest", "fields": [{"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "readGroupIds"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceId"}, {"default": 0, "doc": "", "type": ["long", "null"],
"name": "start"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "end"}, {"default": null, "doc": "", "type": ["null",
"int"], "name": "pageSize"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['end', 'pageSize', 'pageToken', 'readGroupIds', 'referenceId',
                 'start']

    def __init__(self):
        self.end = None
        self.pageSize = None
        self.pageToken = None
        self.readGroupIds = []
        self.referenceId = None
        self.start = 0


class SearchReadsResponse(SearchResponse):
    """
This is the response from `POST /reads/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadsResponse", "fields": [{"default": [], "doc": "", "type":
{"items": {"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadAlignment", "fields": [{"doc": "", "type": ["null", "string"],
"name": "id"}, {"doc": "", "type": "string", "name": "readGroupId"},
{"doc": "", "type": "string", "name": "fragmentName"}, {"default":
false, "doc": "", "type": ["boolean", "null"], "name":
"properPlacement"}, {"default": false, "doc": "", "type": ["boolean",
"null"], "name": "duplicateFragment"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "numberReads"}, {"default": null,
"doc": "", "type": ["null", "int"], "name": "fragmentLength"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"readNumber"}, {"default": false, "doc": "", "type": ["boolean",
"null"], "name": "failedVendorQualityChecks"}, {"default": null,
"doc": "", "type": ["null", {"doc": "", "type": "record", "name":
"LinearAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Side", "fields": [{"doc": "", "type": {"doc": "",
"type": "record", "name": "Position", "fields": [{"default": null,
"doc": "", "type": ["null", "string"], "name": "sequenceId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceName"}, {"doc": "", "type": "long", "name": "position"}]},
"name": "base"}, {"doc": "", "type": {"symbols": ["NEG_STRAND",
"POS_STRAND"], "doc": "", "type": "enum", "name": "Strand"}, "name":
"strand"}]}, "name": "position"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "mappingQuality"}, {"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "CigarUnit",
"fields": [{"doc": "", "type": {"symbols": ["ALIGNMENT_MATCH",
"INSERT", "DELETE", "SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD",
"SEQUENCE_MATCH", "SEQUENCE_MISMATCH"], "doc": "", "type": "enum",
"name": "CigarOperation"}, "name": "operation"}, {"doc": "", "type":
"long", "name": "operationLength"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSequence"}]}, "type":
"array"}, "name": "cigar"}]}, {"doc": "", "type": "record", "name":
"GraphAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Path", "fields": [{"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "Segment",
"fields": [{"doc": "", "type": "Side", "name": "start"}, {"doc": "",
"type": "long", "name": "length"}]}, "type": "array"}, "name":
"segments"}]}, "name": "path"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "mappingQuality"}, {"default": [], "doc": "",
"type": {"items": "CigarUnit", "type": "array"}, "name": "cigar"}]}],
"name": "alignment"}, {"default": false, "doc": "", "type":
["boolean", "null"], "name": "secondaryAlignment"}, {"default": false,
"doc": "", "type": ["boolean", "null"], "name":
"supplementaryAlignment"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "alignedSequence"}, {"default": [], "doc":
"", "type": {"items": "int", "type": "array"}, "name":
"alignedQuality"}, {"default": null, "doc": "", "type": ["null",
"Side"], "name": "nextMatePosition"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}, "type": "array"}, "name":
"alignments"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "alignments"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignments': ReadAlignment,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignments': ReadAlignment,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['alignments', 'nextPageToken']

    def __init__(self):
        self.alignments = []
        self.nextPageToken = None


class SearchReferenceSetsRequest(SearchRequest):
    """
This request maps to the body of `POST /referencesets/search`
as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferenceSetsRequest", "fields": [{"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "md5checksums"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "accessions"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "assemblyId"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "pageSize"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "pageToken"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['accessions', 'assemblyId', 'md5checksums', 'pageSize',
                 'pageToken']

    def __init__(self):
        self.accessions = []
        self.assemblyId = None
        self.md5checksums = []
        self.pageSize = None
        self.pageToken = None


class SearchReferenceSetsResponse(SearchResponse):
    """
This is the response from `POST /referencesets/search`
expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferenceSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "ReferenceSet", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null", {"items":
"string", "type": "array"}], "name": "referenceIds"}, {"default":
null, "doc": "", "type": {"items": "string", "type": "array"}, "name":
"includedReferenceSets"}, {"doc": "", "type": "string", "name":
"md5checksum"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "ncbiTaxonId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "assemblyId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "sourceURI"}, {"doc":
"", "type": {"items": "string", "type": "array"}, "name":
"sourceAccessions"}, {"default": false, "doc": "", "type": "boolean",
"name": "isDerived"}], "doc": ""}, "type": "array"}, "name":
"referenceSets"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "referenceSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'referenceSets': ReferenceSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'referenceSets': ReferenceSet,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['nextPageToken', 'referenceSets']

    def __init__(self):
        self.nextPageToken = None
        self.referenceSets = []


class SearchReferencesRequest(SearchRequest):
    """
This request maps to the body of `POST /references/search`
as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferencesRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSetId"}, {"default": [],
"doc": "", "type": {"items": "string", "type": "array"}, "name":
"sequenceIds"}, {"default": [], "doc": "", "type": {"items": "string",
"type": "array"}, "name": "md5checksums"}, {"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "accessions"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "referenceNames"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "pageSize"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['accessions', 'md5checksums', 'pageSize', 'pageToken',
                 'referenceNames', 'referenceSetId',
                 'sequenceIds']

    def __init__(self):
        self.accessions = []
        self.md5checksums = []
        self.pageSize = None
        self.pageToken = None
        self.referenceNames = []
        self.referenceSetId = None
        self.sequenceIds = []


class SearchReferencesResponse(SearchResponse):
    """
This is the response from `POST /references/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferencesResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Reference", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "sequenceId"}, {"doc":
"", "type": "long", "name": "start"}, {"doc": "", "type": "long",
"name": "length"}, {"doc": "", "type": "string", "name":
"md5checksum"}, {"doc": "", "type": "string", "name": "name"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"sourceURI"}, {"doc": "", "type": {"items": "string", "type":
"array"}, "name": "sourceAccessions"}, {"default": false, "doc": "",
"type": "boolean", "name": "isDerived"}, {"default": null, "doc": "",
"type": ["null", "float"], "name": "sourceDivergence"}, {"default":
null, "doc": "", "type": ["null", "int"], "name": "ncbiTaxonId"},
{"default": true, "doc": "", "type": "boolean", "name": "isPrimary"}],
"doc": ""}, "type": "array"}, "name": "references"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "nextPageToken"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "references"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'references': Reference,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'references': Reference,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['nextPageToken', 'references']

    def __init__(self):
        self.nextPageToken = None
        self.references = []


class SearchSamplesRequest(SearchRequest):
    """
This request maps to the body of `POST /samples/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchSamplesRequest", "fields": [{"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "individualIds"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['individualIds', 'name', 'pageSize', 'pageToken']

    def __init__(self):
        self.individualIds = []
        self.name = None
        self.pageSize = None
        self.pageToken = None


class SearchSamplesResponse(SearchResponse):
    """
This is the response from `POST /samples/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchSamplesResponse", "fields": [{"default": [], "doc": "", "type":
{"items": {"namespace": "org.ga4gh.models", "type": "record", "name":
"Sample", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"individualId"}, {"default": [], "doc": "", "type": {"items":
"string", "type": "array"}, "name": "accessions"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"created"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "updated"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "samplingDate"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "age"}, {"default": null, "doc": "", "type":
["null", {"doc": "", "type": "record", "name": "OntologyTerm",
"fields": [{"doc": "", "type": "string", "name": "ontologySource"},
{"doc": "", "type": "string", "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}]}], "name":
"cellType"}, {"default": null, "doc": "", "type": ["null",
"OntologyTerm"], "name": "cellLine"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "geocode"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "sampleType"},
{"default": null, "doc": "", "type": ["null", "OntologyTerm"], "name":
"organismPart"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name":
"info"}], "doc": ""}, "type": "array"}, "name": "samples"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "samples"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'samples': Sample,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'samples': Sample,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['nextPageToken', 'samples']

    def __init__(self):
        self.nextPageToken = None
        self.samples = []


class SearchSequencesRequest(SearchRequest):
    """
This request maps to the body of `POST /sequences/search` as JSON. Specifies a
number of filters, all of which must be satisfird by each result returned.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchSequencesRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSetId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "variantSetId"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['pageSize', 'pageToken', 'referenceSetId', 'variantSetId']

    def __init__(self):
        self.pageSize = None
        self.pageToken = None
        self.referenceSetId = None
        self.variantSetId = None


class SearchSequencesResponse(SearchResponse):
    """
This is the response from `POST /sequences/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchSequencesResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Sequence", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "long", "name": "length"}], "doc": ""},
"type": "array"}, "name": "sequences"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "sequences"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'sequences': Sequence,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'sequences': Sequence,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['nextPageToken', 'sequences']

    def __init__(self):
        self.nextPageToken = None
        self.sequences = []


class SearchVariantSetsRequest(SearchRequest):
    """
This request maps to the body of `POST /variantsets/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantSetsRequest", "fields": [{"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "datasetIds"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['datasetIds', 'pageSize', 'pageToken']

    def __init__(self):
        self.datasetIds = []
        self.pageSize = None
        self.pageToken = None


class SearchVariantSetsResponse(SearchResponse):
    """
This is the response from `POST /variantsets/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "VariantSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "datasetId"}, {"doc": "",
"type": "string", "name": "referenceSetId"}, {"default": [], "doc":
"", "type": {"items": {"doc": "", "type": "record", "name":
"VariantSetMetadata", "fields": [{"doc": "", "type": "string", "name":
"key"}, {"doc": "", "type": "string", "name": "value"}, {"doc": "",
"type": "string", "name": "id"}, {"doc": "", "type": "string", "name":
"type"}, {"doc": "", "type": "string", "name": "number"}, {"doc": "",
"type": "string", "name": "description"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}, "type": "array"}, "name": "metadata"}],
"doc": ""}, "type": "array"}, "name": "variantSets"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "variantSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variantSets': VariantSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variantSets': VariantSet,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['nextPageToken', 'variantSets']

    def __init__(self):
        self.nextPageToken = None
        self.variantSets = []


class SearchVariantsRequest(SearchRequest):
    """
This request maps to the body of `POST /variants/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantsRequest", "fields": [{"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "variantSetIds"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", {"items":
"string", "type": "array"}], "name": "callSetIds"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "referenceName"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceId"}, {"doc": "", "type": "long", "name": "start"}, {"doc":
"", "type": "long", "name": "end"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "pageSize"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "end",
        "start",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['callSetIds', 'end', 'name', 'pageSize', 'pageToken',
                 'referenceId', 'referenceName', 'start',
                 'variantSetIds']

    def __init__(self):
        self.callSetIds = None
        self.end = None
        self.name = None
        self.pageSize = None
        self.pageToken = None
        self.referenceId = None
        self.referenceName = None
        self.start = None
        self.variantSetIds = []


class SearchVariantsResponse(SearchResponse):
    """
This is the response from `POST /variants/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Variant", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "variantSetId"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "names"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "created"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "updated"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceName"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "start"},
{"default": null, "doc": "", "type": ["null", "long"], "name": "end"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceBases"}, {"default": null, "doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name": "alternateBases"},
{"doc": "", "type": ["null", {"items": "string", "type": "array"}],
"name": "alleleIds"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name": "info"},
{"default": null, "doc": "", "type": ["null", {"items": {"doc": "",
"type": "record", "name": "Call", "fields": [{"doc": "", "type":
["null", "string"], "name": "callSetId"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "callSetName"}, {"doc": "",
"type": ["null", "string"], "name": "variantId"}, {"default": [],
"doc": "", "type": {"items": "int", "type": "array"}, "name":
"genotype"}, {"default": null, "doc": "", "type": ["null", "string",
{"items": "string", "type": "array"}], "name": "phaseset"},
{"default": [], "doc": "", "type": {"items": "double", "type":
"array"}, "name": "genotypeLikelihood"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}, "type": "array"}], "name": "calls"}],
"doc": ""}, "type": "array"}, "name": "variants"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "nextPageToken"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "variants"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variants': Variant,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variants': Variant,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['nextPageToken', 'variants']

    def __init__(self):
        self.nextPageToken = None
        self.variants = []


class Segment(ProtocolElement):
    """
A `Segment` is a range on a `Sequence`. It does not include any base data. (The
bases for a `Sequence` are available through the `getSequenceBases()` API call.)

In the sequence "GTGG", the `Segment` starting at index 1 on the forward strand
with length 2 is the "TG" on the forward strand. The length-2 `Segment` starting
at index 1 on the reverse strand is "AC", corresponding to the first two base
pairs of the sequence, or the last two bases of the reverse complement.

A `Segment` has a left and a right end, in its local orientation (i.e. taking
`Segment.start.strand` to be the `Segment`'s forward strand).
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Segment",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Side", "fields": [{"doc": "", "type": {"doc": "", "type": "record",
"name": "Position", "fields": [{"default": null, "doc": "", "type":
["null", "string"], "name": "sequenceId"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceName"}, {"doc": "",
"type": "long", "name": "position"}]}, "name": "base"}, {"doc": "",
"type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type":
"enum", "name": "Strand"}, "name": "strand"}]}, "name": "start"},
{"doc": "", "type": "long", "name": "length"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "length",
        "start",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'start': Side,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'start': Side,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['length', 'start']

    def __init__(self):
        self.length = None
        self.start = None


class Sequence(ProtocolElement):
    """
Represents a sequence in a sequence graph. May be joined onto parent
`Sequence`(s) at the left and/or right endpoints, and may have other `Sequence`s
as children.

Does not include any base data. The bases for a `Sequence` are available through
the `getSequenceBases()` API call.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Sequence", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": "long", "name": "length"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "length",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['id', 'length']

    def __init__(self):
        self.id = None
        self.length = None


class Side(ProtocolElement):
    """
A `Side` is an oriented base in some already known sequence. A
`Side` is represented by a sequence name or ID, a base number on that
sequence (0-based), and a `Strand` to indicate the forward or reverse-complement
orientation.

For example, given the sequence "GTGG", the `Side` on that sequence at
offset 1 in the forward orientation would be the left side of the T/A base pair.
The base at this `Side` is "T". Alternately, for offset 1 in the reverse
orientation, the `Side` would be the right side of the T/A base pair, and
the base at the `Side` is "A".

Offsets added to a `Side` are interpreted as reading along its strand;
adding to a reverse strand side actually subtracts from its `base.position`
member.

There is a total ordering on sides, assuming a total ordering on
`Sequence`s. Sides are sorted by their `Sequence` (as specified by
`sequenceId` and/or `referenceName`), then within a `Sequence` by their
`position` offsets, and then finally by `Strand`, with `NEG_STRAND` first, then
`POS_STRAND`.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Side",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Position", "fields": [{"default": null, "doc": "", "type": ["null",
"string"], "name": "sequenceId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceName"}, {"doc": "", "type":
"long", "name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "base",
        "strand",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'base': Position,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'base': Position,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['base', 'strand']

    def __init__(self):
        self.base = None
        self.strand = None


class Strand(object):
    """
Indicates the DNA strand associate for some data item.
* `NEG_STRAND`: The negative (-) strand.
* `POS_STRAND`:  The postive (+) strand.
    """
    NEG_STRAND = "NEG_STRAND"
    POS_STRAND = "POS_STRAND"


class SubgraphRadiusRequest(ProtocolElement):
    """
This request maps to the body of `POST /subgraph/radius` as JSON. Specifies
a`Position` and a radius (in bases), and requests the subgraph of all `Join`s
and `Sequence`s reachable within that number of bases from that position.

Starting at the specified `Position`, and with a 0 radius denoting only that
`Position`, walk outwards this many bases along all possible paths, traversing
`Join`s only if necessary. All `Sequences` visited during this walk, and all
`Join`s traversed, should be returned.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SubgraphRadiusRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSetId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "variantSetId"},
{"doc": "", "type": {"namespace": "org.ga4gh.models", "type":
"record", "name": "Position", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "sequenceId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "referenceName"},
{"doc": "", "type": "long", "name": "position"}], "doc": ""}, "name":
"position"}, {"doc": "", "type": "long", "name": "radius"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "position",
        "radius",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'position': Position,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'position': Position,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['pageSize', 'pageToken', 'position', 'radius',
                 'referenceSetId', 'variantSetId']

    def __init__(self):
        self.pageSize = None
        self.pageToken = None
        self.position = None
        self.radius = None
        self.referenceSetId = None
        self.variantSetId = None


class SubgraphRadiusResponse(ProtocolElement):
    """
This is the response from `POST /subgraph/radius` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SubgraphRadiusResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Join", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Side", "fields": [{"doc": "", "type": {"doc": "",
"type": "record", "name": "Position", "fields": [{"default": null,
"doc": "", "type": ["null", "string"], "name": "sequenceId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceName"}, {"doc": "", "type": "long", "name": "position"}]},
"name": "base"}, {"doc": "", "type": {"symbols": ["NEG_STRAND",
"POS_STRAND"], "doc": "", "type": "enum", "name": "Strand"}, "name":
"strand"}]}, "name": "side1"}, {"doc": "", "type": "Side", "name":
"side2"}], "doc": ""}, "type": "array"}, "name": "joins"}, {"default":
[], "doc": "", "type": {"items": {"namespace": "org.ga4gh.models",
"type": "record", "name": "Sequence", "fields": [{"doc": "", "type":
"string", "name": "id"}, {"doc": "", "type": "long", "name":
"length"}], "doc": ""}, "type": "array"}, "name": "sequences"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'joins': Join,
            'sequences': Sequence,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'joins': Join,
            'sequences': Sequence,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['joins', 'nextPageToken', 'sequences']

    def __init__(self):
        self.joins = []
        self.nextPageToken = None
        self.sequences = []


class Variant(ProtocolElement):
    """
A `Variant` represents a change in DNA sequence relative to some reference.
For example, a variant could represent a SNP or an insertion.
Variants belong to a `VariantSet`.
This is equivalent to a row in VCF.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Variant",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"doc": "",
"type": "string", "name": "variantSetId"}, {"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "names"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"created"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "updated"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "start"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "end"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceBases"}, {"default":
null, "doc": "", "type": ["null", {"items": "string", "type":
"array"}], "name": "alternateBases"}, {"doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name": "alleleIds"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}, {"default": null,
"doc": "", "type": ["null", {"items": {"doc": "", "type": "record",
"name": "Call", "fields": [{"doc": "", "type": ["null", "string"],
"name": "callSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "callSetName"}, {"doc": "", "type": ["null",
"string"], "name": "variantId"}, {"default": [], "doc": "", "type":
{"items": "int", "type": "array"}, "name": "genotype"}, {"default":
null, "doc": "", "type": ["null", "string", {"items": "string",
"type": "array"}], "name": "phaseset"}, {"default": [], "doc": "",
"type": {"items": "double", "type": "array"}, "name":
"genotypeLikelihood"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name":
"info"}]}, "type": "array"}], "name": "calls"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "alleleIds",
        "id",
        "variantSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['alleleIds', 'alternateBases', 'calls', 'created', 'end', 'id',
                 'info', 'names', 'referenceBases',
                 'referenceName', 'start', 'updated',
                 'variantSetId']

    def __init__(self):
        self.alleleIds = None
        self.alternateBases = None
        self.calls = None
        self.created = None
        self.end = None
        self.id = None
        self.info = {}
        self.names = []
        self.referenceBases = None
        self.referenceName = None
        self.start = None
        self.updated = None
        self.variantSetId = None


class VariantSet(ProtocolElement):
    """
`Variant` and `CallSet` both belong to a `VariantSet`.
`VariantSet` belongs to a `Dataset`.
The variant set is equivalent to a VCF file.

A `VariantSet` can contain novel `Sequence`s, which are used to augment the
sequence graph of its `ReferenceSet`, creating the augmented sequence graph
against which `Allele`s are interpreted.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"VariantSet", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": "string", "name": "datasetId"}, {"doc": "",
"type": "string", "name": "referenceSetId"}, {"default": [], "doc":
"", "type": {"items": {"doc": "", "type": "record", "name":
"VariantSetMetadata", "fields": [{"doc": "", "type": "string", "name":
"key"}, {"doc": "", "type": "string", "name": "value"}, {"doc": "",
"type": "string", "name": "id"}, {"doc": "", "type": "string", "name":
"type"}, {"doc": "", "type": "string", "name": "number"}, {"doc": "",
"type": "string", "name": "description"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}, "type": "array"}, "name": "metadata"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "datasetId",
        "id",
        "referenceSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'metadata': VariantSetMetadata,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'metadata': VariantSetMetadata,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['datasetId', 'id', 'metadata', 'referenceSetId']

    def __init__(self):
        self.datasetId = None
        self.id = None
        self.metadata = []
        self.referenceSetId = None


class VariantSetMetadata(ProtocolElement):
    """
This metadata represents VCF header information.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"VariantSetMetadata", "fields": [{"doc": "", "type": "string", "name":
"key"}, {"doc": "", "type": "string", "name": "value"}, {"doc": "",
"type": "string", "name": "id"}, {"doc": "", "type": "string", "name":
"type"}, {"doc": "", "type": "string", "name": "number"}, {"doc": "",
"type": "string", "name": "description"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "description",
        "id",
        "key",
        "number",
        "type",
        "value",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['description', 'id', 'info', 'key', 'number', 'type', 'value']

    def __init__(self):
        self.description = None
        self.id = None
        self.info = {}
        self.key = None
        self.number = None
        self.type = None
        self.value = None


class Wiggle(ProtocolElement):
    """
Continuous numerical annotation along a path.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Wiggle",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Path", "fields": [{"default": [], "doc": "", "type": {"items":
{"doc": "", "type": "record", "name": "Segment", "fields": [{"doc":
"", "type": {"doc": "", "type": "record", "name": "Side", "fields":
[{"doc": "", "type": {"doc": "", "type": "record", "name": "Position",
"fields": [{"default": null, "doc": "", "type": ["null", "string"],
"name": "sequenceId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"doc": "", "type": "long",
"name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}]}, "name": "start"}, {"doc": "",
"type": "long", "name": "length"}]}, "type": "array"}, "name":
"segments"}]}, "name": "path"}, {"default": [], "doc": "", "type":
{"items": "float", "type": "array"}, "name": "values"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set(["path"])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'path': Path,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'path': Path,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['path', 'values']

    def __init__(self):
        self.path = None
        self.values = []


class WiggleSet(ProtocolElement):
    """
No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"WiggleSet", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": {"doc": "", "type": "record", "name":
"Attributes", "fields": [{"default": {}, "type": {"values": {"items":
["string", {"doc": "", "type": "record", "name": "ExternalIdentifier",
"fields": [{"doc": "", "type": "string", "name": "database"}, {"doc":
"", "type": "string", "name": "identifier"}, {"doc": "", "type":
"string", "name": "version"}]}, {"doc": "", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"ontologySource"}, {"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}]}], "type": "array"}, "type": "map"}, "name": "vals"}]},
"name": "attributes"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "attributes",
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['attributes', 'id']

    def __init__(self):
        self.attributes = None
        self.id = None

postMethods = \
    [
     # ('/allelecalls/search',
     #  SearchAlleleCallsRequest,
     #  SearchAlleleCallsResponse),
     # ('/alleles/search',
     #  SearchAllelesRequest,
     #  SearchAllelesResponse),
     # ('/analyses/search',
     #  SearchAnalysesRequest,
     #  SearchAnalysesResponse),
     # ('/calls/search',
     #  SearchCallsRequest,
     #  SearchCallsResponse),
     # ('/callsets/search',
     #  SearchCallSetsRequest,
     #  SearchCallSetsResponse),
     # ('/datasets/search',
     #  SearchDatasetsRequest,
     #  SearchDatasetsResponse),
     # ('/experiments/search',
     #  SearchExperimentsRequest,
     #  SearchExperimentsResponse),
     # ('/features/search',
     #  SearchFeaturesRequest,
     #  SearchFeaturesResponse),
     # ('/individualgroups/search',
     #  SearchIndividualGroupsRequest,
     #  SearchIndividualGroupsResponse),
     # ('/individuals/search',
     #  SearchIndividualsRequest,
     #  SearchIndividualsResponse),
     ('/joins/search',
      SearchJoinsRequest,
      SearchJoinsResponse),
     # ('/readgroupsets/search',
     #  SearchReadGroupSetsRequest,
     #  SearchReadGroupSetsResponse),
     # ('/reads/search',
     #  SearchReadsRequest,
     #  SearchReadsResponse),
     ('/references/search',
      SearchReferencesRequest,
      SearchReferencesResponse),
     ('/referencesets/search',
      SearchReferenceSetsRequest,
      SearchReferenceSetsResponse),
     # ('/samples/search',
     #  SearchSamplesRequest,
     #  SearchSamplesResponse),
     ('/sequences/search',
      SearchSequencesRequest,
      SearchSequencesResponse),
     # ('/variants/search',
     #  SearchVariantsRequest,
     #  SearchVariantsResponse),
     # ('/variantsets/search',
     #  SearchVariantSetsRequest,
     #  SearchVariantSetsResponse),
     ('/subgraph/radius',
      SubgraphRadiusRequest,
      SubgraphRadiusResponse)]
